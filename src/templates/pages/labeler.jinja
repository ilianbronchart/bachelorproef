<div id="recording-labeler" class="container-fluid px-4">
  <div id="error-message" class="alert alert-danger mb-4"></div>
  <div class="row">
    <div class="col-md-9">
      <!-- Using mousedown to capture right-clicks -->
      <canvas id="canvas"
              class="mb-3"
              hx-on:mousedown="window.labeler.canvasClick(event)"
              hx-on:mousemove="window.labeler.canvasMouseMove(event)"></canvas>
      <div id="controls" class="d-flex align-items-center gap-2 mb-3">
        <button id="select-mode-btn"
                class="btn btn-secondary"
                type="button"
                hx-on:click="window.labeler.setMode('select')">
          <i class="bi bi-cursor-fill"></i>
        </button>
        <button id="delete-mode-btn"
                class="btn btn-secondary"
                type="button"
                hx-on:click="window.labeler.setMode('delete')">
          <i class="bi bi-trash-fill"></i>
        </button>
        <div id="seek-slider"
             class="seek-bar flex-grow-1"
             hx-on:click="window.labeler.sliderClick(event)">
          <div class="seek-progress"></div>
        </div>
      </div>
      <div id="annotation-list" class="d-flex flex-wrap gap-2 mb-3"></div>
    </div>
    <div class="col-md-3">{% include "components/class-list.jinja" %}</div>
  </div>
</div>
<script>
  // Global labeler object to manage frame fetching, point labeling, segmentation, and annotations.
  window.labeler = {
    canvas: null,
    ctx: null,
    mode: "select", // "select" or "delete"
    currentFrameIndex: 0,
    currentFrameImage: null,
    // annotations is a flat list of annotation objects.
    // Each annotation contains: id, calibration_recording_id, sim_room_class_id, frame_idx,
    // annotation_mask (base64 PNG string), bounding_box (list of 4 ints), and point_labels: [ {x, y, label}, ... ]
    annotations: [],
    recordingUUID: null,
    calibration_id: null,
    frameCount: 0,
    resolution: [1920, 1080],
    hoveredPoint: null,
    sim_room_id: "{{ calibration_recording.sim_room_id }}",
    lastRenderTime: 0,

    init: function(recordingUUID, frameCount, resolution, calibration_id, annotations) {
      this.recordingUUID = recordingUUID;
      this.frameCount = parseInt(frameCount);
      this.resolution = resolution;
      this.calibration_id = calibration_id;
      this.annotations = annotations; // passed in as a list

      this.canvas = document.getElementById("canvas");
      if (!this.canvas) {
        console.error("Canvas element not found");
        return;
      }
      this.ctx = this.canvas.getContext("2d");

      // Prevent context menu on right-click.
      this.canvas.addEventListener("contextmenu", e => e.preventDefault());

      // Load the first frame, set select mode, and start the render loop.
      this.fetchFrame(0);
      this.setMode("select");
      this.renderLoop();

      window.eventBus.on('active-class-changed', () => {
        if (!window.location.href.includes('labeling')) return;
        this.setMode("select");
        this.updateAnnotationList();
      });

      window.eventBus.on('class-deleted', (classId) => {
        if (!window.location.href.includes('labeling')) return;
        this.annotations = this.annotations.filter(ann => ann.sim_room_class_id !== classId);
        this.updateAnnotationList();
      });

      this.updateAnnotationList();
    },

    fetchFrame: function(frameIndex) {
      const url = `/labeling/frames/${frameIndex}`;
      fetch(url)
        .then(response => {
          if (!response.ok) {
            return response.text().then(text => {
              document.getElementById("error-message").innerHTML = text;
              throw new Error(text);
            });
          } else {
            clearError();
            return response.blob();
          }
        })
        .then(blob => {
          const img = new Image();
          img.onload = () => {
            this.canvas.width = img.width;
            this.canvas.height = img.height;
            this.ctx.drawImage(img, 0, 0);
            this.currentFrameImage = img;
            this.currentFrameIndex = frameIndex;
          };
          img.src = URL.createObjectURL(blob);
        })
        .catch(error => {
          console.error("Error fetching frame:", error);
        });
    },

    updateAnnotationList: function() {
      const container = document.getElementById("annotation-list");
      container.innerHTML = ""; // Clear previous thumbnails
      const activeClass = window.classManager.activeClass;
      if (!activeClass) return;
      
      // Filter annotations for the active class that have a valid frame_crop.
      const annotationsForClass = this.annotations.filter(ann =>
        ann.sim_room_class_id == activeClass.id && ann.frame_crop
      );
      
      // Sort annotations by frame index.
      annotationsForClass.sort((a, b) => a.frame_idx - b.frame_idx);
      
      const maxAnnotationSize = 200; // Maximum size for the longest side
      
      annotationsForClass.forEach(ann => {
        // Create an image element for the thumbnail.
        const thumbImg = document.createElement("img");
        thumbImg.style.cursor = "pointer";
        thumbImg.src = "data:image/png;base64," + ann.frame_crop;
        
        // Clicking the thumbnail jumps to that annotationâ€™s frame.
        thumbImg.addEventListener("click", () => {
          this.updateSeekBar();
          this.fetchFrame(ann.frame_idx);
        });
        
        // Create a container for the thumbnail and set its data attribute.
        const thumbContainer = document.createElement("div");
        thumbContainer.classList.add("annotation-thumb");
        thumbContainer.style.display = "inline-block";
        thumbContainer.setAttribute("data-frame", ann.frame_idx);
        // Ensure relative positioning for the cross.
        thumbContainer.style.position = "relative";
        thumbContainer.appendChild(thumbImg);
        
        // Create the delete button instead of a span.
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "btn btn-sm btn-danger annotation-delete";
        deleteBtn.innerHTML = '<i class="bi bi-x-circle align-middle"></i>';
        // The button click deletes the annotation.
        deleteBtn.addEventListener("click", (e) => {
          e.stopPropagation();
          this.deleteAnnotation(ann);
        });
        thumbContainer.appendChild(deleteBtn);
        
        // Resize the image based on its natural dimensions.
        thumbImg.onload = function() {
          const naturalWidth = thumbImg.naturalWidth;
          const naturalHeight = thumbImg.naturalHeight;
          const scale = maxAnnotationSize / Math.max(naturalWidth, naturalHeight);
          thumbImg.width = naturalWidth * scale;
          thumbImg.height = naturalHeight * scale;
        };
        
        container.appendChild(thumbContainer);
      });
    },
    
    sliderClick: function(event) {
      const slider = event.currentTarget;
      const rect = slider.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const percent = clickX / slider.offsetWidth;
      const frameIndex = Math.floor(percent * this.frameCount);
      this.currentFrameIndex = frameIndex;
      this.updateSeekBar();
      this.fetchFrame(frameIndex);
    },

    // Given a frame and classId, return the corresponding annotation (if any)
    getAnnotationForFrameAndClass: function(frame, classId) {
      return this.annotations.find(ann => ann.frame_idx == frame && ann.sim_room_class_id == classId);
    },

    canvasClick: function(event) {
      const rect = this.canvas.getBoundingClientRect();
      const clickX = event.clientX - rect.left;
      const clickY = event.clientY - rect.top;
      // Map displayed coordinates to internal resolution.
      const scaleX = this.resolution[0] / rect.width;
      const scaleY = this.resolution[1] / rect.height;
      const internalX = clickX * scaleX;
      const internalY = clickY * scaleY;

      if (this.mode === "select") {
        event.preventDefault();
        const activeClass = window.classManager.activeClass;
        if (!activeClass) {
          alert("Please select a class first.");
          return;
        }
        // Left-click (button 0) is positive; right-click (button 2) is negative.
        const labelValue = (event.button === 0) ? 1 : 0;
        this.addPoint(activeClass.id, internalX, internalY, labelValue);
      } else if (this.mode === "delete") {
        if (this.hoveredPoint) {
          this.deletePoint(this.hoveredPoint.x, this.hoveredPoint.y, this.hoveredPoint.classId);
          this.hoveredPoint = null;
        }
      }
    },

    // --- Updated canvasMouseMove for delete mode ---
    canvasMouseMove: function(event) {
      if (this.mode !== "delete") return;
      const rect = this.canvas.getBoundingClientRect();
      const mouseX = event.clientX - rect.left;
      const mouseY = event.clientY - rect.top;
      const scaleX = this.resolution[0] / rect.width;
      const scaleY = this.resolution[1] / rect.height;
      const internalX = mouseX * scaleX;
      const internalY = mouseY * scaleY;

      let closest = null;
      let minDist = Infinity;
      const threshold = 20;
      const frame = this.currentFrameIndex;
      // Iterate over all annotations on the current frame.
      this.annotations.filter(ann => ann.frame_idx == frame).forEach(ann => {
        ann.point_labels.forEach((pt, index) => {
          const dist = Math.hypot(pt.x - internalX, pt.y - internalY);
          if (dist < threshold && dist < minDist) {
            closest = { classId: ann.sim_room_class_id, index: index, x: pt.x, y: pt.y, label: pt.label };
            minDist = dist;
          }
        });
      });
      this.hoveredPoint = closest;
    },
    // --- End updated canvasMouseMove ---

    setMode: function(mode) {
      this.mode = mode;
      const selectBtn = document.getElementById("select-mode-btn");
      const deleteBtn = document.getElementById("delete-mode-btn");
      if (mode === "select") {
        selectBtn.classList.add("active");
        deleteBtn.classList.remove("active");
        this.hoveredPoint = null;
      } else if (mode === "delete") {
        deleteBtn.classList.add("active");
        selectBtn.classList.remove("active");
      }
    },

    addPoint: function(classId, x, y, label) {
      const frame = this.currentFrameIndex;
      let ann = this.getAnnotationForFrameAndClass(frame, classId);
      if (!ann) {
        // Create a new annotation object. The mask and bounding box are initially empty;
        // the segmentation endpoint will compute them based on point_labels.
        ann = {
          calibration_recording_id: parseInt(this.calibration_id),
          frame_idx: frame,
          sim_room_class_id: classId,
          annotation_mask: "",
          bounding_box: [],
          point_labels: []
        };
        this.annotations.push(ann);
      }
      ann.point_labels.push({ x, y, label });
      this.updateSegmentation(ann);
    },

    deletePoint: function(x, y, classId) {
      const frame = this.currentFrameIndex;
      const ann = this.getAnnotationForFrameAndClass(frame, classId);
      if (!ann || !ann.point_labels) return;
      const threshold = 20;
      for (let i = 0; i < ann.point_labels.length; i++) {
        const pt = ann.point_labels[i];
        if (Math.hypot(pt.x - x, pt.y - y) < threshold) {
          ann.point_labels.splice(i, 1);
          this.updateSegmentation(ann);
          return;
        }
      }
      this.updateAnnotationList();
    },

    // Send a segmentation request. When a response is received (with new mask and bounding_box),
    // update the annotation and then send the annotation update.
    updateSegmentation: function(annotation) {
      // Changed: if no points remain, delete the annotation instead of sending an empty one.
      if (annotation.point_labels.length === 0) {
        this.deleteAnnotation(annotation);
        return;
      }
      const points = annotation.point_labels.map(pt => [Math.round(pt.x), Math.round(pt.y)]);
      const labels = annotation.point_labels.map(pt => pt.label);
      fetch('/labeling/segmentation', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          calibration_id: parseInt(this.calibration_id),
          frame_idx: annotation.frame_idx,
          points: points,
          labels: labels
        })
      })
      .then(response => {
        if (!response.ok) {
          return response.text().then(text => {
            document.getElementById("error-message").innerHTML = text;
            throw new Error(text);
          });
        } else {
          clearError();
          return response.json();
        }
      })
      .then(data => {
        if (!data.mask) {
          annotation.annotation_mask = "";
          annotation.bounding_box = [];
          this.sendAnnotation(annotation);
          return;
        }
        annotation.annotation_mask = data.mask;
        if (data.bounding_box) {
          annotation.bounding_box = data.bounding_box;
        }
        if (!annotation.img) {
          annotation.img = new Image();
        }
        annotation.img.src = "data:image/png;base64," + data.mask;
        annotation.img.onload = () => {
          this.sendAnnotation(annotation);
        };
      })
      .catch(error => {
        console.error("Segmentation error:", error);
      });
    },

    deleteAnnotation: function(annotation) {
      // If the annotation is not yet saved (has no id), remove it locally.
      if (!annotation.id) {
        this.annotations = this.annotations.filter(ann =>
          !(ann.frame_idx === annotation.frame_idx && ann.sim_room_class_id == annotation.sim_room_class_id)
        );
        this.updateAnnotationList();
        return;
      }
      const url = `/simrooms/${this.sim_room_id}/calibration_recordings/${this.calibration_id}/annotations/${annotation.id}`;
      fetch(url, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' }
      })
      .then(response => {
        if (!response.ok) {
          console.error("Failed to delete annotation:", response.status);
        } else {
          // Remove the deleted annotation from the local list.
          this.annotations = this.annotations.filter(ann => ann.id !== annotation.id);
          this.updateAnnotationList();
        }
      })
      .catch(error => {
        console.error("Annotation delete request failed:", error);
      });
    },

    // POST the updated (or new) annotation. The payload includes bounding_box.
    sendAnnotation: function(annotation) {
      const points = annotation.point_labels.map(pt => [Math.round(pt.x), Math.round(pt.y)]);
      const labels = annotation.point_labels.map(pt => pt.label);
      const payload = {
        calibration_id: parseInt(this.calibration_id),
        frame_idx: annotation.frame_idx,
        sim_room_class_id: annotation.sim_room_class_id,
        points: points,
        labels: labels,
        mask: annotation.annotation_mask,
        frame_crop: annotation.frame_crop,
        bounding_box: annotation.bounding_box
      };
      const url = `/simrooms/${this.sim_room_id}/calibration_recordings/${this.calibration_id}/annotations`;
      fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
      })
      .then(response => {
        if (!response.ok) {
          console.error("Annotation error:", response.status);
          return;
        }
        return response.json();
      })
      .then(updatedAnnotation => {
        if (updatedAnnotation) {
          const idx = this.annotations.findIndex(ann =>
            ann.frame_idx == updatedAnnotation.frame_idx &&
            ann.sim_room_class_id == updatedAnnotation.sim_room_class_id
          );
          if (idx !== -1) {
            this.annotations[idx] = updatedAnnotation;
          } else {
            this.annotations.push(updatedAnnotation);
          }
          this.updateAnnotationList();
        }
      })
      .catch(error => {
        console.error("Annotation request failed:", error);
      });
    },

    // Clear and redraw the current frame along with segmentation overlays and point labels.
    drawAnnotations: function() {
      if (!this.currentFrameImage) return;
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      this.ctx.drawImage(this.currentFrameImage, 0, 0);

      const scaleX_draw = this.canvas.width / this.resolution[0];
      const scaleY_draw = this.canvas.height / this.resolution[1];
      const frame = this.currentFrameIndex;
      const activeClass = window.classManager.activeClass;

      // Iterate over all annotations on the current frame.
      this.annotations.forEach(ann => {
        if (ann.frame_idx == frame) {
          // Get class details from the class manager.
          const cls = window.classManager.classes.find(
            c => parseInt(c.id) === parseInt(ann.sim_room_class_id)
          );
          const classColor = cls ? cls.color : "#0d6efd";

          // Draw segmentation overlay and bounding box (if available) for every annotation.
          if (ann.annotation_mask) {
            if (!ann.img) {
              ann.img = new Image();
              ann.img.src = "data:image/png;base64," + ann.annotation_mask;
            }
            if (ann.bounding_box && ann.bounding_box.length === 4) {
              const [x1, y1, x2, y2] = ann.bounding_box;
              const canvasX1 = x1 * scaleX_draw;
              const canvasY1 = y1 * scaleY_draw;
              const canvasX2 = x2 * scaleX_draw;
              const canvasY2 = y2 * scaleY_draw;
              const width = canvasX2 - canvasX1;
              const height = canvasY2 - canvasY1;
              this.ctx.globalAlpha = 0.3;
              this.ctx.drawImage(ann.img, canvasX1, canvasY1, width, height);
              this.ctx.globalAlpha = 1.0;
              // Draw bounding box stroke.
              this.ctx.strokeStyle = classColor;
              this.ctx.lineWidth = 3;
              this.ctx.strokeRect(canvasX1, canvasY1, width, height);
              // Draw class label at the top of the bounding box.
              this.ctx.font = "bold 16px sans-serif";
              const text = cls ? cls.class_name : "Class " + ann.sim_room_class_id;
              const textMetrics = this.ctx.measureText(text);
              const textWidth = textMetrics.width;
              const textHeight = 16;
              this.ctx.fillStyle = classColor;
              this.ctx.fillRect(canvasX1, canvasY1 - textHeight - 4, textWidth + 4, textHeight + 4);
              this.ctx.fillStyle = "#fff";
              this.ctx.fillText(text, canvasX1 + 2, canvasY1 - 4);
            } else {
              // Fallback: draw the mask over the entire canvas.
              this.ctx.globalAlpha = 0.3;
              this.ctx.drawImage(ann.img, 0, 0, this.canvas.width, this.canvas.height);
              this.ctx.globalAlpha = 1.0;
            }
          }
        }
      });

      // Draw points only for the annotation of the active class.
      if (activeClass) {
        const ann = this.getAnnotationForFrameAndClass(frame, activeClass.id);
        if (ann && ann.point_labels) {
          ann.point_labels.forEach(pt => {
            this.ctx.beginPath();
            const x_render = pt.x * scaleX_draw;
            const y_render = pt.y * scaleY_draw;
            this.ctx.arc(x_render, y_render, 6, 0, 2 * Math.PI);
            // Green for positive (1), red for negative (0).
            this.ctx.fillStyle = (pt.label == 1) ? "#81f542" : "#ff0000";
            this.ctx.fill();
          });
        }
      }

      // If in delete mode and a point is hovered, highlight it.
      if (this.mode === "delete" && this.hoveredPoint) {
        const x_render = this.hoveredPoint.x * scaleX_draw;
        const y_render = this.hoveredPoint.y * scaleY_draw;
        this.ctx.beginPath();
        this.ctx.arc(x_render, y_render, 12, 0, 2 * Math.PI);
        this.ctx.strokeStyle = "#ffeba1";
        this.ctx.lineWidth = 3;
        this.ctx.stroke();
      }
    },

    updateSeekBar: function() {
      const slider = document.getElementById("seek-slider");
      const progress = slider.querySelector(".seek-progress");
      const percent = (this.currentFrameIndex / this.frameCount) * 100;
      progress.style.width = percent + "%";
    },

    updateAnnotationHighlight: function() {
      // Iterate over all annotation thumbnails and update the "selected" class.
      const container = document.getElementById("annotation-list");
      const thumbnails = container.children;
      for (let i = 0; i < thumbnails.length; i++) {
        const thumb = thumbnails[i];
        const frame = parseInt(thumb.getAttribute("data-frame"));
        if (frame === this.currentFrameIndex) {
          thumb.classList.add("selected");
        } else {
          thumb.classList.remove("selected");
        }
      }
    },

    renderLoop: function(timestamp) {
      if (!this.lastRenderTime) {
        this.lastRenderTime = timestamp;
      }
      const elapsed = timestamp - this.lastRenderTime;
      if (elapsed >= 50) {
        this.drawAnnotations();
        this.updateAnnotationHighlight();
        this.lastRenderTime = timestamp;
      }
      requestAnimationFrame(this.renderLoop.bind(this));
    }
  };

  // Initialize the labeler.
  window.labeler.init(
    "{{ calibration_recording.recording_uuid }}", 
    "{{ frame_count }}",
    {{ resolution|tojson }},
    "{{ calibration_recording.id }}",
    {{ annotations|tojson }}
  );
</script>
<style>
.offscreen-video {
  position: absolute;
  left: -9999px;
}
#canvas {
  width: 100%;
  border: 1px solid #ddd;
  border-radius: 0.375rem;
}
#controls .control-btn i {
  font-size: 1.2rem;
}
.btn.active {
  background-color: var(--bs-primary);
  border-color: var(--bs-primary);
  color: white;
}
/* Make list take full height */
.class-management {
  height: 100%;
  display: flex;
  flex-direction: column;
}
.class-list {
  flex-grow: 1;
  overflow-y: auto;
}
.seek-bar {
  position: relative;
  width: 100%;
  height: 16px; /* Increased height for easier clicking */
  background-color: #ddd;
  border-radius: 6px;
  cursor: pointer;
}
.seek-progress {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0;
  background-color: #0d6efd;
  border-radius: 6px;
}

.annotation-thumb {
  border-radius: 5px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  transition: box-shadow 0.2s ease;
  margin: 2px;
  position: relative;
}

.annotation-thumb img {
  border-radius: 5px;
}

.annotation-thumb:hover {
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
}

.annotation-thumb.selected {
  outline: 2px solid #0d6efd;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
}

/* Delete cross styling: hidden by default, visible when hovering the parent */
.annotation-delete {
  position: absolute;
  top: 5px;
  right: 5px;
  cursor: pointer;
  color: white;
  display: none;
  vertical-align: baseline;
}

.annotation-thumb:hover .annotation-delete {
  display: block;
}

</style>

<div id="recording-labeler" class="container-fluid px-4">
  <div id="error" class="alert alert-danger mb-4"></div>
  <div class="row">
    <!-- Left Column: Canvas and Controls -->
    <div class="col-md-9">
      <!-- The canvas where video, masks, and annotations are drawn -->
      <canvas id="canvas"
              class="mb-3"
              hx-on:click="window.labeler.canvasClick(event)"
              hx-on:mousemove="window.labeler.canvasMouseMove(event)"></canvas>
      <!-- Control Bar: Play, Select, Delete, Seek -->
      <div id="controls" class="d-flex align-items-center gap-2 mb-3">
        <button id="play-pause-btn"
                class="btn btn-primary"
                type="button"
                hx-on:click="window.labeler.togglePlayPause()">
          <i class="bi bi-play-fill"></i>
        </button>
        <button id="select-mode-btn"
                class="btn btn-secondary"
                type="button"
                hx-on:click="window.labeler.setMode('select')">
          <i class="bi bi-cursor-fill"></i>
        </button>
        <button id="delete-mode-btn"
                class="btn btn-secondary"
                type="button"
                hx-on:click="window.labeler.setMode('delete')">
          <i class="bi bi-trash-fill"></i>
        </button>
        <!-- Replaced draggable range input with a clickable progress bar -->
        <div id="seek-slider"
             class="seek-bar flex-grow-1"
             hx-on:click="window.labeler.sliderClick(event)">
          <div class="seek-progress"></div>
        </div>
      </div>
    </div>
    <!-- Right Column: Class List -->
    <div class="col-md-3">
      {% with sim_room_id=calibration_recording.sim_room_id, classes=classes %}
        {% include "components/class-list.jinja" %}
      {% endwith %}
    </div>
  </div>
  <!-- Hidden Video (offscreen) -->
  <video id="video"
         class="offscreen-video"
         preload="auto"
         hx-on:loadedmetadata="window.labeler.videoLoadedMetadata(event)"
         hx-on:timeupdate="window.labeler.videoTimeUpdate(event)">
    <source src="{{ url_for('recordings', path=recording_uuid + '.mp4') }}"
            type="video/mp4">
    Your browser does not support the video tag.
  </video>
</div>
<script>
  (function() {
    // Cache DOM elements
    const video          = document.getElementById('video');
    const canvas         = document.getElementById('canvas');
    const slider         = document.getElementById('seek-slider'); // Now a div seek bar.
    const ctx            = canvas.getContext('2d');
    const playPauseBtn   = document.getElementById('play-pause-btn');
    const selectModeBtn  = document.getElementById('select-mode-btn');
    const deleteModeBtn  = document.getElementById('delete-mode-btn');

    // Global labeler object to be used by hx-on event handlers
    window.labeler = {
      video: video,
      canvas: canvas,
      slider: slider,
      ctx: ctx,
      playPauseBtn: playPauseBtn,
      selectModeBtn: selectModeBtn,
      deleteModeBtn: deleteModeBtn,

      // Global state
      annotations: [], // Array of annotations with frame_time already included
      masksByTime: {},  // { frameTime: [ { class: "myClass", mask: <base64> }, ... ] }
      mode: "select",   // "select" or "delete"
      hoveredPoint: null, // Used in delete mode to highlight a point

      // Get current frame time
      getFrameTime: function() {
        return this.video.currentTime;
      },

      // Get annotations for current frame time
      getCurrentAnnotations: function() {
        const currentTime = this.getFrameTime();
        return this.annotations.filter(a => Math.abs(a.frame_time - currentTime) < 0.001);
      },

      // Resize canvas to fill container width and maintain video aspect ratio.
      resizeCanvas: function() {
        const containerWidth = this.canvas.parentElement.offsetWidth;
        if (this.video.videoWidth) {
          this.canvas.width  = containerWidth;
          this.canvas.height = containerWidth * (this.video.videoHeight / this.video.videoWidth);
        } else {
          this.canvas.width  = containerWidth;
          this.canvas.height = containerWidth * (360 / 640);
        }
        // Redraw frame immediately after resize
        if (this.video.readyState >= 2) { // Check if video data is loaded
          this.drawFrame();
        }
      },

      // Draw the video frame, segmentation masks, and annotation points.
      drawFrame: function() {
        this.ctx.drawImage(this.video, 0, 0, this.canvas.width, this.canvas.height);
        const frameTime = this.getFrameTime();

        // Draw segmentation masks for the current frame.
        if (this.masksByTime[frameTime]) {
          this.masksByTime[frameTime].forEach(maskData => {
            const clsObj = window.classManager.classes.find(c => c.label === maskData.class);
            const maskColor = clsObj ? clsObj.color : "#000000";
            const img = new Image();
            img.src = "data:image/png;base64," + maskData.mask;
            img.onload = () => {
              this.ctx.save();
              this.ctx.globalAlpha = 0.5;
              this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);
              this.ctx.globalAlpha = 1.0;
              this.ctx.strokeStyle = maskColor;
              this.ctx.lineWidth = 2;
              this.ctx.strokeRect(0, 0, this.canvas.width, this.canvas.height);
              this.ctx.restore();
            }
          });
        }

        // Draw annotation points for current frame
        const currentAnnotations = this.getCurrentAnnotations();
        for (const annotation of currentAnnotations) {
          for (let i = 0; i < annotation.points.length; i++) {
            const pt = annotation.points[i];
            this.ctx.beginPath();
            this.ctx.arc(pt[0], pt[1], 5, 0, 2 * Math.PI);
            // Left click (1) is green; right click (0) is red.
            this.ctx.fillStyle = (annotation.point_labels[i] === 1) ? "green" : "red";
            this.ctx.fill();
            // If in delete mode and this point is hovered, draw a yellow outline.
            if (this.mode === "delete" && this.hoveredPoint && 
                this.hoveredPoint.label === annotation.label && 
                this.hoveredPoint.index === i) {
              this.ctx.lineWidth = 3;
              this.ctx.strokeStyle = "yellow";
              this.ctx.stroke();
            }
          }
        }
      },

      // Called by the video frame callback to update the canvas.
      updateCanvas: function(now, metadata) {
        this.drawFrame();
        this.video.requestVideoFrameCallback((now, metadata) => { this.updateCanvas(now, metadata); });
      },

      // Toggle video play/pause state.
      togglePlayPause: function() {
        if (this.video.paused) {
          this.video.play();
          this.playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
        } else {
          this.video.pause();
          this.playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
        }
      },

      // Set labeling mode to "select" or "delete" and update button styling.
      setMode: function(newMode) {
        this.mode = newMode;
        if (newMode === "select") {
          this.selectModeBtn.classList.add('active');
          this.deleteModeBtn.classList.remove('active');
        } else if (newMode === "delete") {
          this.deleteModeBtn.classList.add('active');
          this.selectModeBtn.classList.remove('active');
        }
      },

      // Handle click events on the canvas.
      canvasClick: function(event) {
        const rect = this.canvas.getBoundingClientRect();
        const x = parseInt(event.clientX - rect.left);
        const y = parseInt(event.clientY - rect.top);
        const frameTime = this.getFrameTime();

        if (this.mode === "select") {
          const activeClass = window.classManager.activeClass;
          if (!activeClass) {
            alert("Please add/select a class first.");
            return;
          }

          // Find or create annotation for current class and frame
          let annotation = this.getCurrentAnnotations().find(a => a.label === activeClass.label);
          if (!annotation) {
            annotation = {
              label: activeClass.label,
              points: [],
              point_labels: [],
              frame_time: frameTime
            };
            this.annotations.push(annotation);
          }

          // Add new point
          const pointLabel = (event.button === 0) ? 1 : 0;
          annotation.points.push([x, y]);
          annotation.point_labels.push(pointLabel);
          this.sendSegmentationRequest();
        } else if (this.mode === "delete") {
          let found = false;
          const currentAnnotations = this.getCurrentAnnotations();
          for (const annotation of currentAnnotations) {
            for (let i = 0; i < annotation.points.length; i++) {
              const pt = annotation.points[i];
              const dx = pt[0] - x;
              const dy = pt[1] - y;
              if (Math.sqrt(dx * dx + dy * dy) < 10) {
                annotation.points.splice(i, 1);
                annotation.point_labels.splice(i, 1);
                found = true;
                break;
              }
            }
            if (found) break;
          }
          if (found) {
            this.sendSegmentationRequest();
          }
        }
      },

      // In delete mode, track the mouse movement to highlight points for deletion.
      canvasMouseMove: function(event) {
        if (this.mode !== "delete") {
          this.hoveredPoint = null;
          return;
        }
        const rect = this.canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const frameTime = this.getFrameTime();
        const currentAnnotations = this.getCurrentAnnotations();
        this.hoveredPoint = null;
        for (const annotation of currentAnnotations) {
          for (let i = 0; i < annotation.points.length; i++) {
            const pt = annotation.points[i];
            const dx = pt[0] - x;
            const dy = pt[1] - y;
            if (Math.sqrt(dx * dx + dy * dy) < 10) {
              this.hoveredPoint = { label: annotation.label, index: i };
              break;
            }
          }
          if (this.hoveredPoint) break;
        }
      },

      // NEW: Handle click events on the seek bar.
      sliderClick: function(event) {
        const rect = this.slider.getBoundingClientRect();
        const clickX = event.clientX - rect.left;
        const clickFraction = clickX / rect.width;
        const newTime = clickFraction * this.video.duration;
        this.video.currentTime = newTime;
        // Immediately redraw the frame after seeking.
        this.drawFrame();
      },

      // Called when the video metadata is loaded.
      videoLoadedMetadata: function(event) {
        this.resizeCanvas();
        // Render first frame.
        this.video.currentTime = 0;
        if ("requestVideoFrameCallback" in HTMLVideoElement.prototype) {
          this.video.requestVideoFrameCallback((now, metadata) => { this.updateCanvas(now, metadata); });
        } else {
          console.error("Your browser does not support requestVideoFrameCallback().");
        }
      },

      // Update the seek progress bar as the video plays.
      videoTimeUpdate: function(event) {
        const progress = (this.video.currentTime / this.video.duration) * 100;
        const progressBar = this.slider.querySelector('.seek-progress');
        progressBar.style.width = progress + '%';
      },

      // Send segmentation request with the current frame and annotations.
      sendSegmentationRequest: function() {
        const frameTime = this.getFrameTime();
        const currentAnnotations = this.getCurrentAnnotations();
        const annotationsPayload = currentAnnotations.map(a => ({
          label: a.label,
          points: a.points,
          point_labels: a.point_labels
        }));

        // Capture full-resolution video frame
        const offscreen = document.createElement('canvas');
        offscreen.width = this.video.videoWidth;
        offscreen.height = this.video.videoHeight;
        const offCtx = offscreen.getContext('2d');
        offCtx.drawImage(this.video, 0, 0, offscreen.width, offscreen.height);
        const dataURL = offscreen.toDataURL('image/png');
        const frameData = dataURL.split(',')[1];

        // Send segmentation request
        fetch('/labeling/segmentation', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            annotations: annotationsPayload,
            frame: frameData
          })
        })
        .then(response => response.json())
        .then(data => {
          this.masksByTime[frameTime] = data;
          // Save annotations to database after successful segmentation
          this.saveAnnotations(frameTime, annotationsPayload);
        })
        .catch(err => console.error(err));
      },

      saveAnnotations: function(frameTime, annotations) {
        fetch('/calibration_recordings/{{ calibration_recording.id }}/annotations', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            frame_time: frameTime,
            annotations: annotations
          })
        }).catch(err => console.error('Failed to save annotations:', err));
      },

      // Initialize with annotations from the server
      initializeAnnotations() {
        fetch('/calibration_recordings/{{ calibration_recording.id }}/annotations')
          .then(response => response.json())
          .then(annotations => {
            this.annotations = annotations;
            this.renderAnnotations();
          })
          .catch(err => console.error('Failed to load annotations:', err));
      }
    };

    // Initialize annotations when the video is loaded
    video.addEventListener('loadedmetadata', () => {
      window.labeler.initializeAnnotations();
      window.labeler.setMode('select'); // Set default mode to select
    });

    // Add event listeners for video state changes
    video.addEventListener('pause', () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
    });

    // Add debounced resize handler to avoid too many redraws
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        window.labeler.resizeCanvas();
      }, 100); // Wait 100ms after last resize event
    });

    video.addEventListener('ended', () => {
      playPauseBtn.innerHTML = '<i class="bi bi-play-fill"></i>';
    });

    video.addEventListener('play', () => {
      playPauseBtn.innerHTML = '<i class="bi bi-pause-fill"></i>';
    });
  })();
</script>
<style>
  .offscreen-video {
    position: absolute;
    left: -9999px;
  }
  #canvas {
    width: 100%;
    border: 1px solid #ddd;
    border-radius: 0.375rem;
  }
  #controls .control-btn i {
    font-size: 1.2rem;
  }
  .btn.active {
    background-color: var(--bs-primary);
    border-color: var(--bs-primary);
    color: white;
  }
  /* Add vertical spacing between components */
  #recording-labeler {
    min-height: calc(100vh - 56px);  /* Subtract navbar height */
  }
  #recording-labeler .row {
    min-height: inherit;
  }
  #recording-labeler .col-md-3 {
    background: rgba(0,0,0,.01);
    padding: 1.5rem;
    border-right: 1px solid rgba(0,0,0,.1);
  }
  #recording-labeler .col-md-9 {
    padding: 1.5rem;
  }
  /* Make list take full height */
  .class-management {
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  .class-list {
    flex-grow: 1;
    overflow-y: auto;
  }
  .seek-bar {
    position: relative;
    width: 100%;
    height: 16px; /* Increased height for easier clicking */
    background-color: #ddd;
    border-radius: 6px;
    cursor: pointer;
  }
  .seek-progress {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    width: 0;
    background-color: #0d6efd; /* Bootstrap primary color */
    border-radius: 6px;
  }
</style>
